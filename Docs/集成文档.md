# BitRPC é›†æˆæ–‡æ¡£

## æ¦‚è¿°

BitRPC æ˜¯ä¸€ä¸ªåŸºäºä½æ©ç åºåˆ—åŒ–æŠ€æœ¯çš„å¤šè¯­è¨€ç½‘ç»œé€šä¿¡åè®®æ¡†æ¶ã€‚å®ƒå…è®¸åœ¨åè®®å®šä¹‰è¯­è¨€ï¼ˆPDLï¼‰æ–‡ä»¶ä¸­å®šä¹‰åè®®æ•°æ®ç»“æ„å’ŒæœåŠ¡ï¼Œç„¶åè‡ªåŠ¨ç”Ÿæˆ C#ã€Python å’Œ C++ çš„ä»£ç ã€‚

## å¿«é€Ÿå¼€å§‹

### 1. å®šä¹‰åè®®

åˆ›å»º `.pdl` æ–‡ä»¶å®šä¹‰æ‚¨çš„åè®®ï¼š

```pdl
namespace Your.Protocol

message UserInfo {
    int64 user_id = 1
    string username = 2
    string email = 3
    repeated string roles = 4
    bool is_active = 5
    DateTime created_at = 6
}

message LoginRequest {
    string username = 1
    string password = 2
}

message LoginResponse {
    bool success = 1
    UserInfo user = 2
    string token = 3
    string error_message = 4
}

service UserService {
    rpc Login(LoginRequest) returns (LoginResponse)
    rpc GetUser(GetUserRequest) returns (GetUserResponse)
}
```

### 2. é…ç½®ç”Ÿæˆå™¨

ç¼–è¾‘ `generator-config.json`ï¼Œæ”¯æŒè¯­è¨€ç‰¹å®šçš„è¾“å‡ºç›®å½•é…ç½®ï¼š

```json
{
  "protocolFile": "path/to/your/protocol.pdl",
  "outputDirectory": "Generated",
  "languages": [
    {
      "name": "csharp",
      "enabled": true,
      "namespace": "Your.Protocol",
      "runtimePath": "Src",
      "outputDirectory": "Generated/csharp",
      "specificOptions": {
        "RuntimeSubdir": "runtime"
      }
    },
    {
      "name": "python",
      "enabled": true,
      "namespace": "your.protocol",
      "runtimePath": "Src/Python",
      "outputDirectory": "Generated/python",
      "specificOptions": {
        "Python": {
          "UseRelativeImports": true,
          "RuntimeImportBase": ".runtime.bitrpc",
          "RuntimeSubdir": "runtime"
        }
      }
    },
    {
      "name": "cpp",
      "enabled": true,
      "namespace": "your.protocol",
      "runtimePath": "Src/C++Core",
      "outputDirectory": "Generated/cpp",
      "specificOptions": {
        "Cpp": {
          "RuntimeIncludeDir": "runtime",
          "RuntimeSubdir": "runtime"
        }
      }
    }
  ]
}
```

### 3. ç”Ÿæˆä»£ç 

è¿è¡Œç”Ÿæˆå™¨ï¼š

```bash
# ç”Ÿæˆæ‰€æœ‰è¯­è¨€
generate-all.bat

# æˆ–ç”Ÿæˆç‰¹å®šè¯­è¨€
generate-csharp.bat
generate-python.bat
generate-cpp.bat
```

## è¯­è¨€é›†æˆæŒ‡å—

### C# é›†æˆ

#### é¡¹ç›®è®¾ç½®

1. å°†ç”Ÿæˆçš„ C# ä»£ç æ·»åŠ åˆ°æ‚¨çš„é¡¹ç›®ä¸­
2. ç”Ÿæˆçš„ä»£ç ä½äº `Generated/csharp/` ç›®å½•ä¸‹ï¼ŒæŒ‰å‘½åç©ºé—´ç»„ç»‡ï¼š
   - `Generated/csharp/Your/Protocol/Data/` - æ•°æ®ç»“æ„
   - `Generated/csharp/Your/Protocol/Client/` - å®¢æˆ·ç«¯ä»£ç 
   - `Generated/csharp/Your/Protocol/Server/` - æœåŠ¡å™¨ä»£ç 
   - `Generated/csharp/Your/Protocol/Factory/` - å·¥å‚ç±»
3. è¿è¡Œæ—¶åº“ä¼šè‡ªåŠ¨å¤åˆ¶åˆ° `Generated/csharp/runtime/` ç›®å½•
4. æ·»åŠ å¿…è¦çš„ NuGet åŒ…ï¼š

```xml
<PackageReference Include="System.Net.Sockets" Version="4.3.0" />
<PackageReference Include="System.Text.Json" Version="6.0.0" />
```

#### ä½¿ç”¨ç¤ºä¾‹

```csharp
using Your.Protocol;
using Your.Protocol.Client;
using Your.Protocol.Data;

// åˆ›å»ºå®¢æˆ·ç«¯
var client = new UserServiceClient("localhost", 8080);

// ç™»å½•
var loginRequest = new LoginRequest {
    Username = "testuser",
    Password = "password123"
};

var loginResponse = await client.LoginAsync(loginRequest);
if (loginResponse.Success) {
    Console.WriteLine($"Login successful! Token: {loginResponse.Token}");

    // è·å–ç”¨æˆ·ä¿¡æ¯
    var getUserRequest = new GetUserRequest { UserId = loginResponse.User.UserId };
    var userResponse = await client.GetUserAsync(getUserRequest);

    if (userResponse.Found) {
        Console.WriteLine($"User: {userResponse.User.Username}");
    }
}
```

#### å®ç°æœåŠ¡å™¨

```csharp
using Your.Protocol;
using Your.Protocol.Server;
using Your.Protocol.Data;

public class UserServiceImpl : UserServiceBase
{
    public override async Task<LoginResponse> Login(LoginRequest request)
    {
        // å®ç°ç™»å½•é€»è¾‘
        var user = AuthenticateUser(request.Username, request.Password);

        return new LoginResponse {
            Success = user != null,
            User = user,
            Token = user != null ? GenerateToken(user) : null,
            ErrorMessage = user != null ? null : "Invalid credentials"
        };
    }

    public override async Task<GetUserResponse> GetUser(GetUserRequest request)
    {
        // å®ç°è·å–ç”¨æˆ·é€»è¾‘
        var user = GetUserById(request.UserId);

        return new GetUserResponse {
            User = user,
            Found = user != null
        };
    }
}

// å¯åŠ¨æœåŠ¡å™¨
var server = new BitRpcServer(8080);
server.RegisterService<UserServiceImpl>();
await server.StartAsync();
```

### Python é›†æˆ

#### é¡¹ç›®è®¾ç½®

1. å°†ç”Ÿæˆçš„ Python ä»£ç æ·»åŠ åˆ°æ‚¨çš„é¡¹ç›®ä¸­
2. ç”Ÿæˆçš„ä»£ç ä½äº `Generated/python/` ç›®å½•ä¸‹ï¼ŒæŒ‰æ¨¡å—ç»„ç»‡ï¼š
   - `Generated/python/data/` - æ•°æ®ç»“æ„æ¨¡å—
   - `Generated/python/client/` - å®¢æˆ·ç«¯æ¨¡å—
   - `Generated/python/server/` - æœåŠ¡å™¨æ¨¡å—
   - `Generated/python/serialization/` - åºåˆ—åŒ–æ¨¡å—
   - `Generated/python/runtime/` - è¿è¡Œæ—¶åº“ï¼ˆè‡ªåŠ¨å¤åˆ¶ï¼‰
3. å®‰è£…ä¾èµ–ï¼š

```bash
pip install asyncio aiohttp
```

#### å½“å‰çŠ¶æ€è¯´æ˜

**å®Œæˆ**: Pythonè¿è¡Œæ—¶åº“ç°å·²å®Œå…¨å¯¹é½C#å®ç°ï¼Œæä¾›å®Œæ•´çš„åŠŸèƒ½æ”¯æŒï¼š

1. **å®¢æˆ·ç«¯**: å®Œæ•´çš„ `BaseClient` æ¡†æ¶ï¼Œæ”¯æŒ `IRpcClient` æ¥å£å’Œå·¥å‚æ¨¡å¼
2. **æœåŠ¡å™¨ç«¯**: å®Œæ•´çš„ `BaseService` æ¡†æ¶ï¼Œæ”¯æŒæœåŠ¡æ³¨å†Œå’Œæ–¹æ³•åˆ†å‘
3. **åºåˆ—åŒ–**: å®Œæ•´çš„ä½æ©ç åºåˆ—åŒ–ç³»ç»Ÿï¼Œæ”¯æŒç±»å‹å®‰å…¨å’Œé«˜æ•ˆåºåˆ—åŒ–

#### å¯¼å…¥è·¯å¾„è¯´æ˜

Python ä»£ç ä½¿ç”¨ç›¸å¯¹å¯¼å…¥ï¼Œç¡®ä¿ç”Ÿæˆçš„åŒ…ç»“æ„å®Œæ•´ï¼š

```python
# å¯¼å…¥æ–¹å¼
from generated.protocol.data import UserInfo, LoginRequest
from generated.protocol.client import UserServiceClient
```

#### ä½¿ç”¨ç¤ºä¾‹

```python
import asyncio
import sys
import os

# æ·»åŠ ç”Ÿæˆçš„ä»£ç åˆ° Python è·¯å¾„
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'Generated/python'))

from your.protocol.data import UserInfo, LoginRequest, GetUserRequest
from your.protocol.client import UserServiceClient
from .runtime.bitrpc.client import RpcClientFactory  # ä½¿ç”¨å·¥å‚æ¨¡å¼

async def main():
    # ä½¿ç”¨å·¥å‚åˆ›å»ºå®¢æˆ·ç«¯
    client = UserServiceClient.create_tcp_client("localhost", 8080)

    # ç™»å½•
    login_request = LoginRequest(
        username="testuser",
        password="password123"
    )

    try:
        login_response = await client.Login_async(login_request)
        if login_response.success:
            print(f"Login successful! Token: {login_response.token}")

            # è·å–ç”¨æˆ·ä¿¡æ¯
            get_user_request = GetUserRequest(user_id=login_response.user.user_id)
            user_response = await client.GetUser_async(get_user_request)

            if user_response.found:
                print(f"User: {user_response.user.username}")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        await client.disconnect_async()

if __name__ == "__main__":
    asyncio.run(main())
```

#### å®ç°æœåŠ¡å™¨

```python
import asyncio
import sys
import os

# æ·»åŠ ç”Ÿæˆçš„ä»£ç åˆ° Python è·¯å¾„
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'Generated/python'))

from your.protocol.data import UserInfo, LoginRequest, LoginResponse, GetUserRequest, GetUserResponse
from your.protocol.server.testservice_service_base import TestServiceServiceBase
from .runtime.bitrpc.server import RpcServer, ServiceManager

class UserServiceImpl(TestServiceServiceBase):
    """ç”¨æˆ·æœåŠ¡å®ç°"""

    async def Login_async(self, request: LoginRequest) -> LoginResponse:
        """å®ç°ç™»å½•é€»è¾‘"""
        user = self.authenticate_user(request.username, request.password)

        return LoginResponse(
            success=user is not None,
            user=user,
            token=self.generate_token(user) if user else None,
            error_message=None if user else "Invalid credentials"
        )

    async def GetUser_async(self, request: GetUserRequest) -> GetUserResponse:
        """å®ç°è·å–ç”¨æˆ·é€»è¾‘"""
        user = self.get_user_by_id(request.user_id)

        return GetUserResponse(
            user=user,
            found=user is not None
        )

    def authenticate_user(self, username: str, password: str) -> UserInfo:
        """å®ç°èº«ä»½éªŒè¯é€»è¾‘"""
        if username == "testuser" and password == "password123":
            return UserInfo(
                user_id=12345,
                username=username,
                email="test@example.com",
                roles=["user"],
                is_active=True,
                created_at="2023-01-01T00:00:00"
            )
        return None

    def generate_token(self, user: UserInfo) -> str:
        """å®ç°ä»¤ç‰Œç”Ÿæˆé€»è¾‘"""
        return f"token_{user.user_id}_{hash(user.username)}"

    def get_user_by_id(self, user_id: int) -> UserInfo:
        """å®ç°ç”¨æˆ·è·å–é€»è¾‘"""
        if user_id == 12345:
            return UserInfo(
                user_id=user_id,
                username="testuser",
                email="test@example.com",
                roles=["user"],
                is_active=True,
                created_at="2023-01-01T00:00:00"
            )
        return None

async def main():
    # åˆ›å»ºRPCæœåŠ¡å™¨
    server = RpcServer("localhost", 8080)

    # æ³¨å†ŒæœåŠ¡
    UserServiceImpl.register_with_manager(server.service_manager)

    print("Starting server on localhost:8080...")
    await server.start_async()

if __name__ == "__main__":
    asyncio.run(main())
```

### C++ é›†æˆ

#### é¡¹ç›®è®¾ç½®

1. ä½¿ç”¨ç”Ÿæˆçš„ C++ ä»£ç å’Œ CMakeLists.txt
2. ç”Ÿæˆçš„ä»£ç ä½äº `Generated/cpp/` ç›®å½•ä¸‹ï¼š
   - `Generated/cpp/include/` - å¤´æ–‡ä»¶
   - `Generated/cpp/src/` - æºæ–‡ä»¶
   - `Generated/cpp/runtime/` - è¿è¡Œæ—¶åº“ï¼ˆè‡ªåŠ¨å¤åˆ¶ï¼‰
3. ç¼–è¯‘è¿è¡Œæ—¶åº“ï¼š

```bash
cd Generated/cpp
mkdir build
cd build
cmake ..
make
```

#### CMake é…ç½®

ç”Ÿæˆçš„ CMakeLists.txt ä¼šè‡ªåŠ¨åŒ…å«è¿è¡Œæ—¶åº“çš„åŒ…å«è·¯å¾„ï¼š

```cmake
# è¿è¡Œæ—¶åº“åŒ…å«ç›®å½•
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/runtime)

# é“¾æ¥è¿è¡Œæ—¶åº“
target_link_libraries(your_target bitrpc_runtime)
```

#### ä½¿ç”¨ç¤ºä¾‹

```cpp
#include "your/protocol/user_service_client.h"
#include "your/protocol/data/login_request.h"
#include "your/protocol/data/login_response.h"
#include "your/protocol/data/get_user_request.h"
#include "your/protocol/data/get_user_response.h"

using namespace your::protocol;

int main() {
    try {
        // åˆ›å»ºå®¢æˆ·ç«¯
        UserServiceClient client("localhost", 8080);

        // ç™»å½•
        LoginRequest loginRequest;
        loginRequest.set_username("testuser");
        loginRequest.set_password("password123");

        auto loginResponse = client.login(loginRequest);
        if (loginResponse.success()) {
            std::cout << "Login successful! Token: " << loginResponse.token() << std::endl;

            // è·å–ç”¨æˆ·ä¿¡æ¯
            GetUserRequest getUserRequest;
            getUserRequest.set_user_id(loginResponse.user().user_id());

            auto userResponse = client.get_user(getUserRequest);
            if (userResponse.found()) {
                std::cout << "User: " << userResponse.user().username() << std::endl;
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

#### å®ç°æœåŠ¡å™¨

```cpp
#include "your/protocol/user_service_base.h"
#include "your/protocol/data/login_request.h"
#include "your/protocol/data/login_response.h"
#include "your/protocol/data/get_user_request.h"
#include "your/protocol/data/get_user_response.h"
#include "your/protocol/data/user_info.h"

using namespace your::protocol;

class UserServiceImpl : public UserServiceBase {
public:
    LoginResponse login(const LoginRequest& request) override {
        // å®ç°ç™»å½•é€»è¾‘
        auto user = authenticateUser(request.username(), request.password());

        LoginResponse response;
        response.set_success(user != nullptr);
        if (user) {
            response.set_user(*user);
            response.set_token(generateToken(*user));
        } else {
            response.set_error_message("Invalid credentials");
        }

        return response;
    }

    GetUserResponse getUser(const GetUserRequest& request) override {
        // å®ç°è·å–ç”¨æˆ·é€»è¾‘
        auto user = getUserById(request.user_id());

        GetUserResponse response;
        response.set_found(user != nullptr);
        if (user) {
            response.set_user(*user);
        }

        return response;
    }

private:
    std::unique_ptr<UserInfo> authenticateUser(const std::string& username, const std::string& password) {
        // å®ç°èº«ä»½éªŒè¯é€»è¾‘
        return nullptr;
    }

    std::string generateToken(const UserInfo& user) {
        // å®ç°ä»¤ç‰Œç”Ÿæˆé€»è¾‘
        return "";
    }

    std::unique_ptr<UserInfo> getUserById(int64_t userId) {
        // å®ç°ç”¨æˆ·è·å–é€»è¾‘
        return nullptr;
    }
};

int main() {
    try {
        // å¯åŠ¨æœåŠ¡å™¨
        UserServiceImpl service;
        service.start("localhost", 8080);

        std::cout << "Server running on port 8080..." << std::endl;
        service.wait();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

## æ•°æ®ç±»å‹æ”¯æŒ

### åŸºæœ¬ç±»å‹
- `int32`: 32ä½æ•´æ•°
- `int64`: 64ä½æ•´æ•°
- `float`: 32ä½æµ®ç‚¹æ•°
- `double`: 64ä½æµ®ç‚¹æ•°
- `bool`: å¸ƒå°”å€¼
- `string`: å­—ç¬¦ä¸²

### å¤æ‚ç±»å‹
- `repeated`: åˆ—è¡¨/æ•°ç»„
- è‡ªå®šä¹‰æ¶ˆæ¯ç±»å‹
- `DateTime`: æ—¥æœŸæ—¶é—´
- `Vector3`: 3Då‘é‡

## åºåˆ—åŒ–æœºåˆ¶

BitRPC ä½¿ç”¨åŸºäºä½æ©ç çš„é«˜æ•ˆåºåˆ—åŒ–ï¼š

1. **å­—æ®µåˆ†ç»„**: å­—æ®µæŒ‰32ä¸ªä¸€ç»„è¿›è¡Œåˆ†ç»„
2. **ä½æ©ç æ ‡è¯†**: ä½¿ç”¨ä½æ©ç æ ‡è¯†éœ€è¦åºåˆ—åŒ–çš„å­—æ®µï¼ˆéé»˜è®¤å€¼ï¼‰
3. **å·®å¼‚æ•°æ®ä¼ è¾“**: ä»…ä¼ è¾“å˜æ›´çš„å­—æ®µæ•°æ®ï¼Œå‡å°‘è´Ÿè½½å¤§å°

### åºåˆ—åŒ–ç¤ºä¾‹

```csharp
// åˆ›å»ºæ¶ˆæ¯
var user = new UserInfo {
    UserId = 12345,
    Username = "testuser",
    IsActive = true
};

// åºåˆ—åŒ–ä¸ºå­—èŠ‚æ•°ç»„
byte[] data = user.Serialize();

// ååºåˆ—åŒ–
var deserializedUser = UserInfo.Deserialize(data);
```

## é”™è¯¯å¤„ç†

### å®¢æˆ·ç«¯é”™è¯¯å¤„ç†

```csharp
try {
    var response = await client.LoginAsync(request);
} catch (BitRpcException ex) {
    Console.WriteLine($"RPC Error: {ex.Message}");
    Console.WriteLine($"Error Code: {ex.ErrorCode}");
} catch (Exception ex) {
    Console.WriteLine($"Network Error: {ex.Message}");
}
```

### æœåŠ¡å™¨é”™è¯¯å¤„ç†

```csharp
public override async Task<LoginResponse> Login(LoginRequest request)
{
    try {
        // ä¸šåŠ¡é€»è¾‘
        return new LoginResponse { Success = true };
    } catch (AuthenticationException ex) {
        return new LoginResponse {
            Success = false,
            ErrorMessage = "Authentication failed"
        };
    } catch (Exception ex) {
        throw new BitRpcException("Internal server error", 500);
    }
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. è¿æ¥æ± ç®¡ç†

```csharp
// ä½¿ç”¨è¿æ¥æ± 
var clientFactory = new UserServiceClientFactory("localhost", 8080);
using var client = await clientFactory.CreateClientAsync();
```

### 2. æ‰¹é‡æ“ä½œ

```csharp
// æ‰¹é‡å‘é€è¯·æ±‚
var requests = new List<GetUserRequest>();
// ... æ·»åŠ è¯·æ±‚

var responses = await Task.WhenAll(
    requests.Select(r => client.GetUserAsync(r))
);
```

### 3. å¼‚æ­¥å¤„ç†

```python
# Python å¼‚æ­¥å¤„ç†
async def process_users(user_ids):
    tasks = [client.get_user(GetUserRequest(user_id=id)) for id in user_ids]
    return await asyncio.gather(*tasks)
```

## é…ç½®é€‰é¡¹è¯¦è§£

### ç”Ÿæˆå™¨é…ç½®å‚æ•°

#### åŸºç¡€é…ç½®
- `protocolFile`: åè®®å®šä¹‰æ–‡ä»¶è·¯å¾„
- `outputDirectory`: åŸºç¡€è¾“å‡ºç›®å½•
- `languages`: è¯­è¨€é…ç½®æ•°ç»„

#### è¯­è¨€é…ç½®
- `name`: è¯­è¨€åç§° (csharp, python, cpp)
- `enabled`: æ˜¯å¦å¯ç”¨è¯¥è¯­è¨€
- `namespace`: ç›®æ ‡å‘½åç©ºé—´
- `runtimePath`: è¿è¡Œæ—¶åº“æºè·¯å¾„
- `outputDirectory`: è¯¥è¯­è¨€çš„è¾“å‡ºç›®å½•ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸ºåŸºç¡€è¾“å‡ºç›®å½•+è¯­è¨€åï¼‰
- `specificOptions`: è¯­è¨€ç‰¹å®šé€‰é¡¹

#### è¯­è¨€ç‰¹å®šé€‰é¡¹

**C# é€‰é¡¹:**
```json
{
  "RuntimeSubdir": "runtime"  // è¿è¡Œæ—¶å­ç›®å½•åç§°
}
```

**Python é€‰é¡¹:**
```json
{
  "Python": {
    "UseRelativeImports": true,        // ä½¿ç”¨ç›¸å¯¹å¯¼å…¥
    "RuntimeImportBase": ".runtime.bitrpc",  // è¿è¡Œæ—¶å¯¼å…¥åŸºç¡€è·¯å¾„
    "RuntimeSubdir": "runtime"         // è¿è¡Œæ—¶å­ç›®å½•åç§°
  }
}
```

**C++ é€‰é¡¹:**
```json
{
  "Cpp": {
    "RuntimeIncludeDir": "runtime",    // è¿è¡Œæ—¶åŒ…å«ç›®å½•
    "RuntimeSubdir": "runtime"        // è¿è¡Œæ—¶å­ç›®å½•åç§°
  }
}
```

### æ–‡ä»¶è·¯å¾„å¤„ç†è§„åˆ™

1. **è¾“å‡ºç›®å½•ç»“æ„**:
   - C#: `Generated/csharp/Your/Namespace/`
   - Python: `Generated/python/`
   - C++: `Generated/cpp/`

2. **è¿è¡Œæ—¶åº“è‡ªåŠ¨å¤åˆ¶**:
   - å½“ `runtimePath` é…ç½®ä¸”ç›®å½•å­˜åœ¨æ—¶ï¼Œè‡ªåŠ¨å¤åˆ¶åˆ°è¾“å‡ºç›®å½•
   - é»˜è®¤å¤åˆ¶åˆ° `runtime/` å­ç›®å½•
   - å¯é€šè¿‡ `RuntimeSubdir` é€‰é¡¹è‡ªå®šä¹‰

3. **Python åŒ…ç»“æ„**:
   - è‡ªåŠ¨åˆ›å»º `__init__.py` æ–‡ä»¶
   - æ”¯æŒç›¸å¯¹å¯¼å…¥å’ŒåŒ…ç»“æ„

## éƒ¨ç½²å»ºè®®

### 1. å®¹å™¨åŒ–éƒ¨ç½²

```dockerfile
# C# æœåŠ¡å™¨ Dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY . .
EXPOSE 8080
ENTRYPOINT ["dotnet", "YourServer.dll"]
```

### 2. è´Ÿè½½å‡è¡¡

- ä½¿ç”¨åå‘ä»£ç†ï¼ˆNginxã€HAProxyï¼‰
- å®ç°å¥åº·æ£€æŸ¥ç«¯ç‚¹
- é…ç½®è‡ªåŠ¨æ‰©å±•

### 3. ç›‘æ§å’Œæ—¥å¿—

```csharp
// æ·»åŠ æ—¥å¿—è®°å½•
public class LoggingUserService : UserServiceBase
{
    private readonly ILogger _logger;
    private readonly UserService _service;

    public LoggingUserService(UserService service, ILogger logger)
    {
        _service = service;
        _logger = logger;
    }

    public override async Task<LoginResponse> Login(LoginRequest request)
    {
        _logger.LogInformation("Login attempt for user: {Username}", request.Username);

        try {
            var result = await _service.Login(request);
            _logger.LogInformation("Login {Result} for user: {Username}",
                result.Success ? "successful" : "failed", request.Username);
            return result;
        } catch (Exception ex) {
            _logger.LogError(ex, "Login error for user: {Username}", request.Username);
            throw;
        }
    }
}
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

1. **è¿æ¥è¶…æ—¶**
   - æ£€æŸ¥ç½‘ç»œè¿æ¥
   - éªŒè¯æœåŠ¡å™¨æ˜¯å¦è¿è¡Œ
   - è°ƒæ•´è¶…æ—¶è®¾ç½®

2. **åºåˆ—åŒ–é”™è¯¯**
   - ç¡®ä¿æ•°æ®ç±»å‹åŒ¹é…
   - æ£€æŸ¥åè®®å®šä¹‰ä¸€è‡´æ€§
   - éªŒè¯å­—æ®µç¼–å·

3. **ç‰ˆæœ¬å…¼å®¹æ€§**
   - ä¿æŒåè®®å®šä¹‰å‘åå…¼å®¹
   - ä½¿ç”¨å¯é€‰å­—æ®µ
   - å®ç°ç‰ˆæœ¬åå•†

### è°ƒè¯•å·¥å…·

```csharp
// å¯ç”¨è°ƒè¯•æ¨¡å¼
client.EnableDebugLogging = true;
client.OnMessageSent += (msg) => Console.WriteLine($"Sent: {msg}");
client.OnMessageReceived += (msg) => Console.WriteLine($"Received: {msg}");
```

## æœ€ä½³å®è·µ

1. **åè®®è®¾è®¡**
   - ä½¿ç”¨æ˜ç¡®çš„å­—æ®µå‘½å
   - ä¿æŒå‘åå…¼å®¹æ€§
   - åˆç†ä½¿ç”¨å¯é€‰å­—æ®µ

2. **é”™è¯¯å¤„ç†**
   - å®ç°å…¨é¢çš„é”™è¯¯å¤„ç†
   - æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯æ¶ˆæ¯
   - è®°å½•é”™è¯¯æ—¥å¿—

3. **æ€§èƒ½ä¼˜åŒ–**
   - ä½¿ç”¨è¿æ¥æ± 
   - å®ç°ç¼“å­˜æœºåˆ¶
   - æ‰¹é‡å¤„ç†è¯·æ±‚

4. **å®‰å…¨æ€§**
   - å®ç°èº«ä»½éªŒè¯
   - ä½¿ç”¨åŠ å¯†é€šä¿¡
   - è¾“å…¥éªŒè¯å’Œæ¸…ç†

## æ”¯æŒçš„è¯­è¨€çŠ¶æ€

| è¯­è¨€ | å®¢æˆ·ç«¯ | æœåŠ¡å™¨ | åºåˆ—åŒ– | å·¥å‚ç±» | çŠ¶æ€ |
|------|--------|--------|--------|--------|------|
| C# | âœ… å®Œæ•´ | âœ… å®Œæ•´ | âœ… å®Œæ•´ | âœ… å®Œæ•´ | ç”Ÿäº§å°±ç»ª |
| Python | âœ… å®Œæ•´ | âœ… å®Œæ•´ | âœ… å®Œæ•´ | âœ… å®Œæ•´ | ç”Ÿäº§å°±ç»ª |
| C++ | ğŸš§ åŸºç¡€ | ğŸš§ å¼€å‘ä¸­ | ğŸš§ åŸºç¡€ | âœ… å®Œæ•´ | å¼€å‘ä¸­ |

### è¯­è¨€å·®å¼‚è¯´æ˜

#### PythonåŠŸèƒ½ç‰¹æ€§ï¼š
1. **å®¢æˆ·ç«¯æ¡†æ¶**ï¼šå®Œæ•´çš„ `BaseClient` æ¡†æ¶ï¼Œæ”¯æŒ `IRpcClient` æ¥å£å’Œå·¥å‚æ¨¡å¼
2. **æœåŠ¡å™¨ç«¯**ï¼šå®Œæ•´çš„ `BaseService` æ¡†æ¶ï¼Œæ”¯æŒæœåŠ¡æ³¨å†Œå’Œæ–¹æ³•åˆ†å‘
3. **åºåˆ—åŒ–**ï¼šå®Œæ•´çš„ä½æ©ç åºåˆ—åŒ–ç³»ç»Ÿï¼Œæ”¯æŒç±»å‹å®‰å…¨å’Œé«˜æ•ˆåºåˆ—åŒ–
4. **å¼‚æ­¥æ”¯æŒ**ï¼šå®Œå…¨åŸºäº `asyncio` çš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹
5. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œå¼‚å¸¸ç®¡ç†æœºåˆ¶

#### ä½¿ç”¨å»ºè®®ï¼š
1. **ç”Ÿäº§ç¯å¢ƒ**ï¼šPythonè¿è¡Œæ—¶åº“ç°å·²å®Œå…¨å¯¹é½C#ï¼Œå¯ç”¨äºç”Ÿäº§ç¯å¢ƒ
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨è¿æ¥æ± å’Œæ‰¹é‡æ“ä½œæé«˜æ€§èƒ½
3. **æ‰©å±•æ€§**ï¼šæ”¯æŒè‡ªå®šä¹‰ç±»å‹å¤„ç†å™¨å’Œåºåˆ—åŒ–é€»è¾‘

## æ”¯æŒ

å¦‚éœ€æŠ€æœ¯æ”¯æŒï¼Œè¯·å‚è€ƒä»¥ä¸‹èµ„æºï¼š

1. é¡¹ç›®æ–‡æ¡£ï¼š`Docs/` ç›®å½•
2. ç¤ºä¾‹ä»£ç ï¼š`Examples/` ç›®å½•
3. é—®é¢˜æŠ¥å‘Šï¼šé€šè¿‡ GitHub Issues
4. ç¤¾åŒºè®¨è®ºï¼šé¡¹ç›®è®¨è®ºåŒº