# BitRPC 集成文档

## 概述

BitRPC 是一个基于位掩码序列化技术的多语言网络通信协议框架。它允许在协议定义语言（PDL）文件中定义协议数据结构和服务，然后自动生成 C#、Python 和 C++ 的代码。

## 快速开始

### 1. 定义协议

创建 `.pdl` 文件定义您的协议：

```pdl
namespace Your.Protocol

message UserInfo {
    int64 user_id = 1
    string username = 2
    string email = 3
    repeated string roles = 4
    bool is_active = 5
    DateTime created_at = 6
}

message LoginRequest {
    string username = 1
    string password = 2
}

message LoginResponse {
    bool success = 1
    UserInfo user = 2
    string token = 3
    string error_message = 4
}

service UserService {
    rpc Login(LoginRequest) returns (LoginResponse)
    rpc GetUser(GetUserRequest) returns (GetUserResponse)
}
```

### 2. 配置生成器

编辑 `generator-config.json`，支持语言特定的输出目录配置：

```json
{
  "protocolFile": "path/to/your/protocol.pdl",
  "outputDirectory": "Generated",
  "languages": [
    {
      "name": "csharp",
      "enabled": true,
      "namespace": "Your.Protocol",
      "runtimePath": "Src",
      "outputDirectory": "Generated/csharp",
      "specificOptions": {
        "RuntimeSubdir": "runtime"
      }
    },
    {
      "name": "python",
      "enabled": true,
      "namespace": "your.protocol",
      "runtimePath": "Src/Python",
      "outputDirectory": "Generated/python",
      "specificOptions": {
        "Python": {
          "UseRelativeImports": true,
          "RuntimeImportBase": ".runtime.bitrpc",
          "RuntimeSubdir": "runtime"
        }
      }
    },
    {
      "name": "cpp",
      "enabled": true,
      "namespace": "your.protocol",
      "runtimePath": "Src/C++Core",
      "outputDirectory": "Generated/cpp",
      "specificOptions": {
        "Cpp": {
          "RuntimeIncludeDir": "runtime",
          "RuntimeSubdir": "runtime"
        }
      }
    }
  ]
}
```

### 3. 生成代码

运行生成器：

```bash
# 生成所有语言
generate-all.bat

# 或生成特定语言
generate-csharp.bat
generate-python.bat
generate-cpp.bat
```

## 语言集成指南

### C# 集成

#### 项目设置

1. 将生成的 C# 代码添加到您的项目中
2. 生成的代码位于 `Generated/csharp/` 目录下，按命名空间组织：
   - `Generated/csharp/Your/Protocol/Data/` - 数据结构
   - `Generated/csharp/Your/Protocol/Client/` - 客户端代码
   - `Generated/csharp/Your/Protocol/Server/` - 服务器代码
   - `Generated/csharp/Your/Protocol/Factory/` - 工厂类
3. 运行时库会自动复制到 `Generated/csharp/runtime/` 目录
4. 添加必要的 NuGet 包：

```xml
<PackageReference Include="System.Net.Sockets" Version="4.3.0" />
<PackageReference Include="System.Text.Json" Version="6.0.0" />
```

#### 使用示例

```csharp
using Your.Protocol;
using Your.Protocol.Client;
using Your.Protocol.Data;

// 创建客户端
var client = new UserServiceClient("localhost", 8080);

// 登录
var loginRequest = new LoginRequest {
    Username = "testuser",
    Password = "password123"
};

var loginResponse = await client.LoginAsync(loginRequest);
if (loginResponse.Success) {
    Console.WriteLine($"Login successful! Token: {loginResponse.Token}");

    // 获取用户信息
    var getUserRequest = new GetUserRequest { UserId = loginResponse.User.UserId };
    var userResponse = await client.GetUserAsync(getUserRequest);

    if (userResponse.Found) {
        Console.WriteLine($"User: {userResponse.User.Username}");
    }
}
```

#### 实现服务器

```csharp
using Your.Protocol;
using Your.Protocol.Server;
using Your.Protocol.Data;

public class UserServiceImpl : UserServiceBase
{
    public override async Task<LoginResponse> Login(LoginRequest request)
    {
        // 实现登录逻辑
        var user = AuthenticateUser(request.Username, request.Password);

        return new LoginResponse {
            Success = user != null,
            User = user,
            Token = user != null ? GenerateToken(user) : null,
            ErrorMessage = user != null ? null : "Invalid credentials"
        };
    }

    public override async Task<GetUserResponse> GetUser(GetUserRequest request)
    {
        // 实现获取用户逻辑
        var user = GetUserById(request.UserId);

        return new GetUserResponse {
            User = user,
            Found = user != null
        };
    }
}

// 启动服务器
var server = new BitRpcServer(8080);
server.RegisterService<UserServiceImpl>();
await server.StartAsync();
```

### Python 集成

#### 项目设置

1. 将生成的 Python 代码添加到您的项目中
2. 生成的代码位于 `Generated/python/` 目录下，按模块组织：
   - `Generated/python/data/` - 数据结构模块
   - `Generated/python/client/` - 客户端模块
   - `Generated/python/server/` - 服务器模块
   - `Generated/python/serialization/` - 序列化模块
   - `Generated/python/runtime/` - 运行时库（自动复制）
3. 安装依赖：

```bash
pip install asyncio aiohttp
```

#### 当前状态说明

**完成**: Python运行时库现已完全对齐C#实现，提供完整的功能支持：

1. **客户端**: 完整的 `BaseClient` 框架，支持 `IRpcClient` 接口和工厂模式
2. **服务器端**: 完整的 `BaseService` 框架，支持服务注册和方法分发
3. **序列化**: 完整的位掩码序列化系统，支持类型安全和高效序列化

#### 导入路径说明

Python 代码使用相对导入，确保生成的包结构完整：

```python
# 导入方式
from generated.protocol.data import UserInfo, LoginRequest
from generated.protocol.client import UserServiceClient
```

#### 使用示例

```python
import asyncio
import sys
import os

# 添加生成的代码到 Python 路径
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'Generated/python'))

from your.protocol.data import UserInfo, LoginRequest, GetUserRequest
from your.protocol.client import UserServiceClient
from .runtime.bitrpc.client import RpcClientFactory  # 使用工厂模式

async def main():
    # 使用工厂创建客户端
    client = UserServiceClient.create_tcp_client("localhost", 8080)

    # 登录
    login_request = LoginRequest(
        username="testuser",
        password="password123"
    )

    try:
        login_response = await client.Login_async(login_request)
        if login_response.success:
            print(f"Login successful! Token: {login_response.token}")

            # 获取用户信息
            get_user_request = GetUserRequest(user_id=login_response.user.user_id)
            user_response = await client.GetUser_async(get_user_request)

            if user_response.found:
                print(f"User: {user_response.user.username}")
    except Exception as e:
        print(f"Error: {e}")
    finally:
        await client.disconnect_async()

if __name__ == "__main__":
    asyncio.run(main())
```

#### 实现服务器

```python
import asyncio
import sys
import os

# 添加生成的代码到 Python 路径
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'Generated/python'))

from your.protocol.data import UserInfo, LoginRequest, LoginResponse, GetUserRequest, GetUserResponse
from your.protocol.server.testservice_service_base import TestServiceServiceBase
from .runtime.bitrpc.server import RpcServer, ServiceManager

class UserServiceImpl(TestServiceServiceBase):
    """用户服务实现"""

    async def Login_async(self, request: LoginRequest) -> LoginResponse:
        """实现登录逻辑"""
        user = self.authenticate_user(request.username, request.password)

        return LoginResponse(
            success=user is not None,
            user=user,
            token=self.generate_token(user) if user else None,
            error_message=None if user else "Invalid credentials"
        )

    async def GetUser_async(self, request: GetUserRequest) -> GetUserResponse:
        """实现获取用户逻辑"""
        user = self.get_user_by_id(request.user_id)

        return GetUserResponse(
            user=user,
            found=user is not None
        )

    def authenticate_user(self, username: str, password: str) -> UserInfo:
        """实现身份验证逻辑"""
        if username == "testuser" and password == "password123":
            return UserInfo(
                user_id=12345,
                username=username,
                email="test@example.com",
                roles=["user"],
                is_active=True,
                created_at="2023-01-01T00:00:00"
            )
        return None

    def generate_token(self, user: UserInfo) -> str:
        """实现令牌生成逻辑"""
        return f"token_{user.user_id}_{hash(user.username)}"

    def get_user_by_id(self, user_id: int) -> UserInfo:
        """实现用户获取逻辑"""
        if user_id == 12345:
            return UserInfo(
                user_id=user_id,
                username="testuser",
                email="test@example.com",
                roles=["user"],
                is_active=True,
                created_at="2023-01-01T00:00:00"
            )
        return None

async def main():
    # 创建RPC服务器
    server = RpcServer("localhost", 8080)

    # 注册服务
    UserServiceImpl.register_with_manager(server.service_manager)

    print("Starting server on localhost:8080...")
    await server.start_async()

if __name__ == "__main__":
    asyncio.run(main())
```

### C++ 集成

#### 项目设置

1. 使用生成的 C++ 代码和 CMakeLists.txt
2. 生成的代码位于 `Generated/cpp/` 目录下：
   - `Generated/cpp/include/` - 头文件
   - `Generated/cpp/src/` - 源文件
   - `Generated/cpp/runtime/` - 运行时库（自动复制）
3. 编译运行时库：

```bash
cd Generated/cpp
mkdir build
cd build
cmake ..
make
```

#### CMake 配置

生成的 CMakeLists.txt 会自动包含运行时库的包含路径：

```cmake
# 运行时库包含目录
include_directories(${CMAKE_CURRENT_SOURCE_DIR}/runtime)

# 链接运行时库
target_link_libraries(your_target bitrpc_runtime)
```

#### 使用示例

```cpp
#include "your/protocol/user_service_client.h"
#include "your/protocol/data/login_request.h"
#include "your/protocol/data/login_response.h"
#include "your/protocol/data/get_user_request.h"
#include "your/protocol/data/get_user_response.h"

using namespace your::protocol;

int main() {
    try {
        // 创建客户端
        UserServiceClient client("localhost", 8080);

        // 登录
        LoginRequest loginRequest;
        loginRequest.set_username("testuser");
        loginRequest.set_password("password123");

        auto loginResponse = client.login(loginRequest);
        if (loginResponse.success()) {
            std::cout << "Login successful! Token: " << loginResponse.token() << std::endl;

            // 获取用户信息
            GetUserRequest getUserRequest;
            getUserRequest.set_user_id(loginResponse.user().user_id());

            auto userResponse = client.get_user(getUserRequest);
            if (userResponse.found()) {
                std::cout << "User: " << userResponse.user().username() << std::endl;
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

#### 实现服务器

```cpp
#include "your/protocol/user_service_base.h"
#include "your/protocol/data/login_request.h"
#include "your/protocol/data/login_response.h"
#include "your/protocol/data/get_user_request.h"
#include "your/protocol/data/get_user_response.h"
#include "your/protocol/data/user_info.h"

using namespace your::protocol;

class UserServiceImpl : public UserServiceBase {
public:
    LoginResponse login(const LoginRequest& request) override {
        // 实现登录逻辑
        auto user = authenticateUser(request.username(), request.password());

        LoginResponse response;
        response.set_success(user != nullptr);
        if (user) {
            response.set_user(*user);
            response.set_token(generateToken(*user));
        } else {
            response.set_error_message("Invalid credentials");
        }

        return response;
    }

    GetUserResponse getUser(const GetUserRequest& request) override {
        // 实现获取用户逻辑
        auto user = getUserById(request.user_id());

        GetUserResponse response;
        response.set_found(user != nullptr);
        if (user) {
            response.set_user(*user);
        }

        return response;
    }

private:
    std::unique_ptr<UserInfo> authenticateUser(const std::string& username, const std::string& password) {
        // 实现身份验证逻辑
        return nullptr;
    }

    std::string generateToken(const UserInfo& user) {
        // 实现令牌生成逻辑
        return "";
    }

    std::unique_ptr<UserInfo> getUserById(int64_t userId) {
        // 实现用户获取逻辑
        return nullptr;
    }
};

int main() {
    try {
        // 启动服务器
        UserServiceImpl service;
        service.start("localhost", 8080);

        std::cout << "Server running on port 8080..." << std::endl;
        service.wait();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

## 数据类型支持

### 基本类型
- `int32`: 32位整数
- `int64`: 64位整数
- `float`: 32位浮点数
- `double`: 64位浮点数
- `bool`: 布尔值
- `string`: 字符串

### 复杂类型
- `repeated`: 列表/数组
- 自定义消息类型
- `DateTime`: 日期时间
- `Vector3`: 3D向量

## 序列化机制

BitRPC 使用基于位掩码的高效序列化：

1. **字段分组**: 字段按32个一组进行分组
2. **位掩码标识**: 使用位掩码标识需要序列化的字段（非默认值）
3. **差异数据传输**: 仅传输变更的字段数据，减少负载大小

### 序列化示例

```csharp
// 创建消息
var user = new UserInfo {
    UserId = 12345,
    Username = "testuser",
    IsActive = true
};

// 序列化为字节数组
byte[] data = user.Serialize();

// 反序列化
var deserializedUser = UserInfo.Deserialize(data);
```

## 错误处理

### 客户端错误处理

```csharp
try {
    var response = await client.LoginAsync(request);
} catch (BitRpcException ex) {
    Console.WriteLine($"RPC Error: {ex.Message}");
    Console.WriteLine($"Error Code: {ex.ErrorCode}");
} catch (Exception ex) {
    Console.WriteLine($"Network Error: {ex.Message}");
}
```

### 服务器错误处理

```csharp
public override async Task<LoginResponse> Login(LoginRequest request)
{
    try {
        // 业务逻辑
        return new LoginResponse { Success = true };
    } catch (AuthenticationException ex) {
        return new LoginResponse {
            Success = false,
            ErrorMessage = "Authentication failed"
        };
    } catch (Exception ex) {
        throw new BitRpcException("Internal server error", 500);
    }
}
```

## 性能优化

### 1. 连接池管理

```csharp
// 使用连接池
var clientFactory = new UserServiceClientFactory("localhost", 8080);
using var client = await clientFactory.CreateClientAsync();
```

### 2. 批量操作

```csharp
// 批量发送请求
var requests = new List<GetUserRequest>();
// ... 添加请求

var responses = await Task.WhenAll(
    requests.Select(r => client.GetUserAsync(r))
);
```

### 3. 异步处理

```python
# Python 异步处理
async def process_users(user_ids):
    tasks = [client.get_user(GetUserRequest(user_id=id)) for id in user_ids]
    return await asyncio.gather(*tasks)
```

## 配置选项详解

### 生成器配置参数

#### 基础配置
- `protocolFile`: 协议定义文件路径
- `outputDirectory`: 基础输出目录
- `languages`: 语言配置数组

#### 语言配置
- `name`: 语言名称 (csharp, python, cpp)
- `enabled`: 是否启用该语言
- `namespace`: 目标命名空间
- `runtimePath`: 运行时库源路径
- `outputDirectory`: 该语言的输出目录（可选，默认为基础输出目录+语言名）
- `specificOptions`: 语言特定选项

#### 语言特定选项

**C# 选项:**
```json
{
  "RuntimeSubdir": "runtime"  // 运行时子目录名称
}
```

**Python 选项:**
```json
{
  "Python": {
    "UseRelativeImports": true,        // 使用相对导入
    "RuntimeImportBase": ".runtime.bitrpc",  // 运行时导入基础路径
    "RuntimeSubdir": "runtime"         // 运行时子目录名称
  }
}
```

**C++ 选项:**
```json
{
  "Cpp": {
    "RuntimeIncludeDir": "runtime",    // 运行时包含目录
    "RuntimeSubdir": "runtime"        // 运行时子目录名称
  }
}
```

### 文件路径处理规则

1. **输出目录结构**:
   - C#: `Generated/csharp/Your/Namespace/`
   - Python: `Generated/python/`
   - C++: `Generated/cpp/`

2. **运行时库自动复制**:
   - 当 `runtimePath` 配置且目录存在时，自动复制到输出目录
   - 默认复制到 `runtime/` 子目录
   - 可通过 `RuntimeSubdir` 选项自定义

3. **Python 包结构**:
   - 自动创建 `__init__.py` 文件
   - 支持相对导入和包结构

## 部署建议

### 1. 容器化部署

```dockerfile
# C# 服务器 Dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY . .
EXPOSE 8080
ENTRYPOINT ["dotnet", "YourServer.dll"]
```

### 2. 负载均衡

- 使用反向代理（Nginx、HAProxy）
- 实现健康检查端点
- 配置自动扩展

### 3. 监控和日志

```csharp
// 添加日志记录
public class LoggingUserService : UserServiceBase
{
    private readonly ILogger _logger;
    private readonly UserService _service;

    public LoggingUserService(UserService service, ILogger logger)
    {
        _service = service;
        _logger = logger;
    }

    public override async Task<LoginResponse> Login(LoginRequest request)
    {
        _logger.LogInformation("Login attempt for user: {Username}", request.Username);

        try {
            var result = await _service.Login(request);
            _logger.LogInformation("Login {Result} for user: {Username}",
                result.Success ? "successful" : "failed", request.Username);
            return result;
        } catch (Exception ex) {
            _logger.LogError(ex, "Login error for user: {Username}", request.Username);
            throw;
        }
    }
}
```

## 故障排除

### 常见问题

1. **连接超时**
   - 检查网络连接
   - 验证服务器是否运行
   - 调整超时设置

2. **序列化错误**
   - 确保数据类型匹配
   - 检查协议定义一致性
   - 验证字段编号

3. **版本兼容性**
   - 保持协议定义向后兼容
   - 使用可选字段
   - 实现版本协商

### 调试工具

```csharp
// 启用调试模式
client.EnableDebugLogging = true;
client.OnMessageSent += (msg) => Console.WriteLine($"Sent: {msg}");
client.OnMessageReceived += (msg) => Console.WriteLine($"Received: {msg}");
```

## 最佳实践

1. **协议设计**
   - 使用明确的字段命名
   - 保持向后兼容性
   - 合理使用可选字段

2. **错误处理**
   - 实现全面的错误处理
   - 提供有意义的错误消息
   - 记录错误日志

3. **性能优化**
   - 使用连接池
   - 实现缓存机制
   - 批量处理请求

4. **安全性**
   - 实现身份验证
   - 使用加密通信
   - 输入验证和清理

## 支持的语言状态

| 语言 | 客户端 | 服务器 | 序列化 | 工厂类 | 状态 |
|------|--------|--------|--------|--------|------|
| C# | ✅ 完整 | ✅ 完整 | ✅ 完整 | ✅ 完整 | 生产就绪 |
| Python | ✅ 完整 | ✅ 完整 | ✅ 完整 | ✅ 完整 | 生产就绪 |
| C++ | 🚧 基础 | 🚧 开发中 | 🚧 基础 | ✅ 完整 | 开发中 |

### 语言差异说明

#### Python功能特性：
1. **客户端框架**：完整的 `BaseClient` 框架，支持 `IRpcClient` 接口和工厂模式
2. **服务器端**：完整的 `BaseService` 框架，支持服务注册和方法分发
3. **序列化**：完整的位掩码序列化系统，支持类型安全和高效序列化
4. **异步支持**：完全基于 `asyncio` 的异步编程模型
5. **错误处理**：完善的错误处理和异常管理机制

#### 使用建议：
1. **生产环境**：Python运行时库现已完全对齐C#，可用于生产环境
2. **性能优化**：使用连接池和批量操作提高性能
3. **扩展性**：支持自定义类型处理器和序列化逻辑

## 支持

如需技术支持，请参考以下资源：

1. 项目文档：`Docs/` 目录
2. 示例代码：`Examples/` 目录
3. 问题报告：通过 GitHub Issues
4. 社区讨论：项目讨论区