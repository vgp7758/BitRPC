// Generated by BitRPC Protocol Generator
// File: GetUserResponse_serializer.cpp
// Language: Cpp

#include "../include/getuserresponse_serializer.h"

namespace bitrpc {
namespace test::protocol {

int GetUserResponseSerializer::hash_code() const { return -1624387005; }

bool is_default_getuserresponse(const GetUserResponse* value) {
    if (value == nullptr) return true;
    const auto& obj = *value;
    if (!is_default_userinfo(&obj.user)) return false;
    if (obj.found != false) return false;
    return true;
}

bool is_default_getuserresponse(const GetUserResponse& value) { return is_default_getuserresponse(&value); }

void GetUserResponseSerializer::write(const void* obj, StreamWriter& writer) const {
    const auto& obj_ref = *static_cast<const GetUserResponse*>(obj);
    uint32_t mask0 = 0;
    if (!is_default_userinfo(&obj_ref.user)) mask0 |= (1u << 0);
    if (!(obj_ref.found == false)) mask0 |= (1u << 1);
    writer.write_uint32(mask0);
    if (mask0 & (1u << 0)) { UserInfoSerializer::serialize(obj_ref.user, writer); }
    if (mask0 & (1u << 1)) { BoolHandler::instance().write(&obj_ref.found, writer); }
}

void* GetUserResponseSerializer::read(StreamReader& reader) const {
    auto obj_ptr = std::make_unique<GetUserResponse>();
    uint32_t mask0 = reader.read_uint32();
    if (mask0 & (1u << 0)) { obj_ptr->user = *UserInfoSerializer::deserialize(reader); }
    if (mask0 & (1u << 1)) { obj_ptr->found = *static_cast<bool*>(BoolHandler::instance().read(reader)); }
    return obj_ptr.release();
}

void GetUserResponseSerializer::serialize(const GetUserResponse& obj, StreamWriter& writer) { instance().write(&obj, writer); }
std::unique_ptr<GetUserResponse> GetUserResponseSerializer::deserialize(StreamReader& reader) { auto obj_ptr = std::unique_ptr<GetUserResponse>(static_cast<GetUserResponse*>(instance().read(reader))); return obj_ptr; }

}} // namespace bitrpc
