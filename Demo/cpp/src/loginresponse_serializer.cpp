// Generated by BitRPC Protocol Generator
// File: LoginResponse_serializer.cpp
// Language: Cpp

#include "../include/loginresponse_serializer.h"

namespace bitrpc {
namespace example::protocol {

int LoginResponseSerializer::hash_code() const { return 100275685; }

bool is_default_loginresponse(const LoginResponse* value) {
    if (value == nullptr) return true;
    const auto& obj = *value;
    if (obj.success != false) return false;
    if (!is_default_userinfo(&obj.user)) return false;
    if (obj.token != "") return false;
    if (obj.error_message != "") return false;
    return true;
}

bool is_default_loginresponse(const LoginResponse& value) { return is_default_loginresponse(&value); }

void LoginResponseSerializer::write(const void* obj, StreamWriter& writer) const {
    const auto& obj_ref = *static_cast<const LoginResponse*>(obj);
    uint32_t mask0 = 0;
    if (!(obj_ref.success == false)) mask0 |= (1u << 0);
    if (!is_default_userinfo(&obj_ref.user)) mask0 |= (1u << 1);
    if (!(obj_ref.token == "")) mask0 |= (1u << 2);
    if (!(obj_ref.error_message == "")) mask0 |= (1u << 3);
    writer.write_uint32(mask0);
    if (mask0 & (1u << 0)) { BoolHandler::instance().write(&obj_ref.success, writer); }
    if (mask0 & (1u << 1)) { UserInfoSerializer::serialize(obj_ref.user, writer); }
    if (mask0 & (1u << 2)) { StringHandler::instance().write(&obj_ref.token, writer); }
    if (mask0 & (1u << 3)) { StringHandler::instance().write(&obj_ref.error_message, writer); }
}

void* LoginResponseSerializer::read(StreamReader& reader) const {
    auto obj_ptr = make_unique<LoginResponse>();
    uint32_t mask0 = reader.read_uint32();
    if (mask0 & (1u << 0)) { obj_ptr->success = *static_cast<bool*>(BoolHandler::instance().read(reader)); }
    if (mask0 & (1u << 1)) { obj_ptr->user = *UserInfoSerializer::deserialize(reader); }
    if (mask0 & (1u << 2)) { obj_ptr->token = *static_cast<std::string*>(StringHandler::instance().read(reader)); }
    if (mask0 & (1u << 3)) { obj_ptr->error_message = *static_cast<std::string*>(StringHandler::instance().read(reader)); }
    return obj_ptr.release();
}

void LoginResponseSerializer::serialize(const LoginResponse& obj, StreamWriter& writer) { instance().write(&obj, writer); }
std::unique_ptr<LoginResponse> LoginResponseSerializer::deserialize(StreamReader& reader) { auto obj_ptr = std::unique_ptr<LoginResponse>(static_cast<LoginResponse*>(instance().read(reader))); return obj_ptr; }

}} // namespace bitrpc
